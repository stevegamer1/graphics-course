# PBR

В данном задании вам предстоит познакомиться с PBR (physically based rendering, рендеринг, основанный на физике) и наконец-то добавить материалы в ваш рендерер, если вы конечно ещё этого не сделали.

## Перед началом

1. Скопируйте в эту папку любой рендерер уже рисующий что-то, аналогично предыдущим заданиям.
   В идеале он должен включать в себя все релевантные предыдущие домашки.
2. Вспомните материал занятия про PBR.


## Задание

#### Шаг 1

Добавьте в [SceneManager](/common/scene/SceneManager.hpp) абстракцию материала: набора числовых констант и текстур, передаваемых в пиксельный шейдер при отрисовке.
Каждый материал должен содержать следующие параметры:

- текстуры базового цвета, шершавости, металличности, эмиссивности, карты нормалей,
- константные значения этих параметров как взаимоисключающая альтернатива текстур.

Каждому `RenderElement` должен соответствовать фиксированный материал.
Загрузите все эти данные из файла модели.

##### Методическая рекомендация

Для айдишников материалов и текстур используйте типы вроде `enum class SomeId : uint32_t { Invalid = ~uint32_t{0}; };` вместо обычных интов.
Это позволит вам никогда не запутаться, где у вас какой конкретно айдишник, и не передать случайно айди материала в функцию ожидающую айди текстуры.
Более того, это позволит хранить материалы в памяти более компактно чем если использовать указатели, тем самым повышая эффективность кэшей CPU.
Наконец, используя айдишники и вектора с проверкой выхода за границы мы гарантированно избегаем мерзких багов с протухшими после пуш-бэка указателями.

#### Шаг 2

Добавьте в ваш основной шейдер сцены чтение параметров из материала.
Для случая константных параметров предлагается создавать изображения 1x1 пиксель, в единственном пикселе которых лежит требуемый параметр.
Обратите внимание, что текстуры базового цвета и эмиссивности в glTF закодированы функцией перехода sRGB, а поэтому загружать их нужно в изображение формата `R8G8B8A8_SRGB`, чтобы вулкан автоматом за вас сделал обратное преобразование (так же известное как гамма-коррекция).
Текстура металличности/шершавости при этом закодирована линейно, а поэтому должна использовать формат `R8G8B8A8_UNORM`.
Нормали считывайте из карты нормалей в базисе образуемом вершинной нормалью, тангентом и битангентом, где последний вычисляйте согласно спецификации glTF.

Если у вас есть G-буфер, добавьте в него дополнительную информацию о материале и записывайте её туда в шейдере сцены.
Иначе переходите к следующему шагу.

Если у вас используется мульти-дро, то вам придётся частично отключить его, делая отдельный вызов отрисовки для каждого материала.
Побороть эту проблему в будущем нам поможет техника bindless.

#### Шаг 3

Прочитайте внимательно раздел [B.2](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#material-structure) спецификации glTF.
Не забудьте пройтись по ссылкам на статьи.

Поменяйте код вычисления освещения так, чтобы он использовал микрофасетную модель GGX описанную в спецификации glTF с параметрами, считанными из материала.

Чтобы показывать хоть что-то в отражениях на металлических поверхностях, добавьте в ваше приложение скайбокс и используйте его и для отражений, и в качестве фона всей сцены.

## Бонусный уровень

???

## Полезные материалы

1. https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#materials &mdash; формат хранения материалов в glTF
2. https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#material-structure &mdash; предполагаемый моделями glTF метод PBR-освещения
3. https://www.graphics.cornell.edu/~westin/pubs/TorranceSparrowJOSA1967.pdf &mdash; микрофасетная модель
4. https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf &mdash; распределение GGX
5. https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=183db641ff80ff21234040ccce884cb06227dad4 &mdash; приближение Шлика для коэффициента Френеля
